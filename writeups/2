    LVM 2: Boolean Writup
=============================
The original lambda expression is like:

    (Î» ABCDEF GHIJKL | (#â‰ƒ A #.) ((#â‰  B #?) #ğ… (...)) #ğ…)

Define macro:

    .l(ğ¬) (Î»xyz|y(xyz))                   -> successor
    .l(ğ“) (Î»xy|x)                         -> true
    .l(ğ…) (Î»xy|y)                         -> false
    .l(Â¬) (Î»w|w#ğ…#ğ“)                      -> not
    .l(Î¶) (Î»x|x #ğ… #Â¬ #ğ…)                 -> zerop
    .l(ğ©) (Î»xsz|x(Î»gh|h(gs))(Î»u|z)(Î»u|u)) -> predecessor
    .l(âˆ¸) (Î»xy|y#ğ©x)                      -> monus subtraction
    .l(âˆ§) (Î»wz|wz#ğ…)                      -> and
    .l(â‰ƒ) (Î»ab|(#âˆ§(#Î¶(#âˆ¸ab))(#Î¶(#âˆ¸ba))))  -> equalp
    .l(â‰ ) (Î»jk|#Â¬(#â‰ƒjk))                  -> neq_p
    .l(+) (Î»xy|y#ğ¬x)                      -> addition
    .l(Ã—) (Î»xys|x(ys))                    -> multiplication

It is generated by Python code, see `2.py' for details.

But it should notice that the given lambda expression is
not computed in the ABCDEFGHIJKL sequence, you can reorder
the original lambda expression like:

    (Î»KCJIHEBLADGF|...)

1. copy the lambda calculus function body and save it as a
   Python string:

       expr = "(Î»w|w(Î»xy|y)(Î»xy|..."

2. you can get the variable by its appearance:

       ''.join(re.compile("[A-Z]").findall(expr))
       # => KCJIHEBLADGF

Think it is not strict (general) enough? Sure, you could
take use of the AST by:

       from parse import parse
       expr_ast = parse("...") # the function

       def search(ast : AST, depth : int = 0) -> None:
           if ast.terminate_p() and re.match("[A-Z]", ast.root):
               print(f"{ast}: {depth}")
           elif ast.application_p():
               search(ast.fn_expr(), depth + 1)
               search(ast.arg_expr(), depth + 1)
           elif ast.function_p():
               search(ast.fn_body(), depth + 1)

So change the `task-2-lambda-expr' like this:

    .l(f) \ -> set the secret lambda function expression
        (Î»K|(Î»C|(Î»J|(Î»I|(Î»H|(Î»E|(Î»B|(Î»L|(Î»A|(Î»D|(Î»G|(Î»F|((((Î»w|((w(Î»\
        x|(Î»y|y)))(Î»x|(Î»y|x))))(((Î»a|(Î»b|(((Î»w|(Î»z|((wz)(Î»x|(Î»y|y)))\

Or, you can construct a reorder function like below:

    .l(r) (Î»fKCJIHEBLADGF|fABCDEFGHIJKL)

so the original f could be used as:

    .l(g) #r #f

now you can crack it one by one in sequence.

If you've followed the tips, you may found out that:

   .l(t) (Î»AB|(#â‰ƒA#1)((#â‰ƒB#2)#ğ“#ğ…)#ğ…)
   #t #1 #2 -> (Î»xy|x)
   #t #2    -> (Î»Bxy|y)
   #t #1    -> (Î»B|B(Î»gh|h(g(Î»gh|h(g(Î»xy|y)))))(Î»u|(Î»uw|w(Î»xy|y)(Î»xy|x)))(Î»u|u)(Î»u|u)(Î»xy|y)(B(Î»xsz|x(Î»gh|h(gs))(Î»u|z)(Î»u|u))(Î»sz|s(sz))(Î»xy|y)(Î»w|w(Î»xy|y)(Î»xy|x))(Î»xy|y))(Î»xy|y)(Î»xy|x)(Î»xy|y))

samely, you can test the task lambda expr one by one:

   #f #1 -> (Î»CJIHEBLADGFxy|y)
   #f #2 -> (Î»CJIHEBLADGFxy|y)
   ...
   #f #8 -> (Î»CJIHEBLADGF|C(Î»xsz|x(Î»gh|h(gs))(Î»u|z)(Î»u|u))(Î»ya|y(y(y(y(y(y(y(y(y(y(y(y(ya))))))))))... so the "first" K is 8 -> `h'.

since trying each bit is a little slow, it is wiser to
write a program and try checking it every time.

a lazy way to do this is like:

   from utils import AST
   from parse import parse
   from compute import compute
   from lvm_repl import make_church_number
   expr_ast = parse("...") # the task lambda expr
   syms = "KCJIHEBLADGF"
   flag = [char for char in "************"]
   ast = expr_ast
   for j in syms:
       max_len, max_i, max_res = 0, 0, None
       for i in range(26):
           res = compute(AST("â†", ast, make_church_number(i + 1)), 512)
           if len(str(res)) > max_len:
               max_len, max_i, max_res = len(str(res)), i, res
       ast, flag[ord(j) - ord("A")] = max_res, chr(max_i + ord("a"))

   ''.join(flag) # => lambdaknight

So the flag is `ucatflags{lambdaknight}'.

see `2-solve.py' for a more complete and general code to do such thing.

Do you have other method to solve this problem?
(of cource there should be other ways, for example,
reduce the lambda expression by hand, or use other
brute force to guess.).

Quote:
   ã•ã¦ã©ã“ã¸è¡Œã“ã†ã‹ã—ã‚‰ã­ã€ãƒãƒƒãƒˆã¯åºƒå¤§ã ã‚
                                   è‰è–™ç´ å­

P.S. do you know lambda knight?
  * https://en.wikipedia.org/wiki/Knights_of_the_Lambda_Calculus
  * and it also appears in animation `Serial Experiments Lain'
    see https://anime.mit.edu/resources/mit_in_anime
