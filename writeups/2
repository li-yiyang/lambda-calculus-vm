    LVM 2: Boolean Writup
=============================
The original lambda expression is like:

    (λ ABCDEF GHIJKL | (#≃ A #.) ((#≠ B #?) #𝐅 (...)) #𝐅)

Define macro:

    .l(𝐬) (λxyz|y(xyz))                   -> successor
    .l(𝐓) (λxy|x)                         -> true
    .l(𝐅) (λxy|y)                         -> false
    .l(¬) (λw|w#𝐅#𝐓)                      -> not
    .l(ζ) (λx|x #𝐅 #¬ #𝐅)                 -> zerop
    .l(𝐩) (λxsz|x(λgh|h(gs))(λu|z)(λu|u)) -> predecessor
    .l(∸) (λxy|y#𝐩x)                      -> monus subtraction
    .l(∧) (λwz|wz#𝐅)                      -> and
    .l(≃) (λab|(#∧(#ζ(#∸ab))(#ζ(#∸ba))))  -> equalp
    .l(≠) (λjk|#¬(#≃jk))                  -> neq_p
    .l(+) (λxy|y#𝐬x)                      -> addition
    .l(×) (λxys|x(ys))                    -> multiplication

It is generated by Python code, see `2.py' for details.

But it should notice that the given lambda expression is
not computed in the ABCDEFGHIJKL sequence, you can reorder
the original lambda expression like:

    (λKCJIHEBLADGF|...)

1. copy the lambda calculus function body and save it as a
   Python string:

       expr = "(λw|w(λxy|y)(λxy|..."

2. you can get the variable by its appearance:

       ''.join(re.compile("[A-Z]").findall(expr))
       # => KCJIHEBLADGF

Think it is not strict (general) enough? Sure, you could
take use of the AST by:

       from parse import parse
       expr_ast = parse("...") # the function

       def search(ast : AST, depth : int = 0) -> None:
           if ast.terminate_p() and re.match("[A-Z]", ast.root):
               print(f"{ast}: {depth}")
           elif ast.application_p():
               search(ast.fn_expr(), depth + 1)
               search(ast.arg_expr(), depth + 1)
           elif ast.function_p():
               search(ast.fn_body(), depth + 1)

So change the `task-2-lambda-expr' like this:

    .l(f) \ -> set the secret lambda function expression
        (λK|(λC|(λJ|(λI|(λH|(λE|(λB|(λL|(λA|(λD|(λG|(λF|((((λw|((w(λ\
        x|(λy|y)))(λx|(λy|x))))(((λa|(λb|(((λw|(λz|((wz)(λx|(λy|y)))\

Or, you can construct a reorder function like below:

    .l(r) (λfKCJIHEBLADGF|fABCDEFGHIJKL)

so the original f could be used as:

    .l(g) #r #f

now you can crack it one by one in sequence.

If you've followed the tips, you may found out that:

   .l(t) (λAB|(#≃A#1)((#≃B#2)#𝐓#𝐅)#𝐅)
   #t #1 #2 -> (λxy|x)
   #t #2    -> (λBxy|y)
   #t #1    -> (λB|B(λgh|h(g(λgh|h(g(λxy|y)))))(λu|(λuw|w(λxy|y)(λxy|x)))(λu|u)(λu|u)(λxy|y)(B(λxsz|x(λgh|h(gs))(λu|z)(λu|u))(λsz|s(sz))(λxy|y)(λw|w(λxy|y)(λxy|x))(λxy|y))(λxy|y)(λxy|x)(λxy|y))

samely, you can test the task lambda expr one by one:

   #f #1 -> (λCJIHEBLADGFxy|y)
   #f #2 -> (λCJIHEBLADGFxy|y)
   ...
   #f #8 -> (λCJIHEBLADGF|C(λxsz|x(λgh|h(gs))(λu|z)(λu|u))(λya|y(y(y(y(y(y(y(y(y(y(y(y(ya))))))))))... so the "first" K is 8 -> `h'.

since trying each bit is a little slow, it is wiser to
write a program and try checking it every time.

a lazy way to do this is like:

   from utils import AST
   from parse import parse
   from compute import compute
   from lvm_repl import make_church_number
   expr_ast = parse("...") # the task lambda expr
   syms = "KCJIHEBLADGF"
   flag = [char for char in "************"]
   ast = expr_ast
   for j in syms:
       max_len, max_i, max_res = 0, 0, None
       for i in range(26):
           res = compute(AST("←", ast, make_church_number(i + 1)), 512)
           if len(str(res)) > max_len:
               max_len, max_i, max_res = len(str(res)), i, res
       ast, flag[ord(j) - ord("A")] = max_res, chr(max_i + ord("a"))

   ''.join(flag) # => lambdaknight

So the flag is `ucatflags{lambdaknight}'.

see `2-solve.py' for a more complete and general code to do such thing.

Do you have other method to solve this problem?
(of cource there should be other ways, for example,
reduce the lambda expression by hand, or use other
brute force to guess.).

Quote:
   さてどこへ行こうかしらね、ネットは広大だわ
                                   草薙素子

P.S. do you know lambda knight?
  * https://en.wikipedia.org/wiki/Knights_of_the_Lambda_Calculus
  * and it also appears in animation `Serial Experiments Lain'
    see https://anime.mit.edu/resources/mit_in_anime
